/*
 *      Copyright (C) 2012-2015 DataStax Inc.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
package com.datastax.driver.core;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.util.concurrent.TimeUnit.NANOSECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * Base implementation for monotonic timestamp generators.
 */
abstract class AbstractMonotonicTimestampGenerator implements TimestampGenerator {

    private static final Logger LOGGER = LoggerFactory.getLogger(TimestampGenerator.class);

    private static final long CLOCK_DRIFT_WARNING_INTERVAL = NANOSECONDS.convert(1, SECONDS);

    @VisibleForTesting
    volatile Clock clock = ClockFactory.newInstance();

    private volatile long lastClockDriftWarning = Long.MIN_VALUE;

    /**
     * Compute the next timestamp, given the last timestamp previously generated.
     * <p/>
     * The returned timestamp should be strictly greater than the previous one.
     * If this is not the case, a warning will be logged once every second.
     * To disable these warnings, set the
     * {@code com.datastax.driver.core.TimestampGenerator} logger level
     * to {@code OFF}.
     * <p/>
     * This implementation is inspired by {@code org.apache.cassandra.service.ClientState#getTimestamp()}.
     *
     * @param last The last timestamp generated by this generator, in microseconds.
     * @return the next timestamp to use, in microseconds.
     */
    protected long computeNext(long last) {
        long current = clock.currentTimeMicros();
        if (last >= current) {
            maybeLogWarning(current, last);
            return last + 1;
        }
        return current;
    }

    private void maybeLogWarning(long current, long last) {
        if (LOGGER.isWarnEnabled()) {
            long now = System.nanoTime();
            if (now > lastClockDriftWarning + CLOCK_DRIFT_WARNING_INTERVAL) {
                lastClockDriftWarning = now;
                if (current == last) {
                    LOGGER.warn(
                            "Clock drift detected: same timestamp was generated twice ({}), " +
                                    "returned timestamps will be artificially incremented to guarantee monotonicity. " +
                                    "This message will only be logged once every second.",
                            current);
                } else {
                    LOGGER.warn(
                            "Clock skew detected: current timestamp ({}) was {} microseconds behind last timestamp ({}), " +
                                    "returned timestamps will be artificially incremented to guarantee monotonicity. " +
                                    "This message will only be logged once every second.",
                            current, last - current, last);
                }
            }
        }
    }

}
